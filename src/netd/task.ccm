/*
 * This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or distribute
 * this software, either in source code form or as a compiled binary, for any
 * purpose, commercial or non-commercial, and by any means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors of
 * this software dedicate any and all copyright interest in the software to the
 * public domain. We make this dedication for the benefit of the public at
 * large and to the detriment of our heirs and successors. We intend this
 * dedication to be an overt act of relinquishment in perpetuity of all present
 * and future rights to this software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

module;

/*
 * a task is an awaitable object representing a suspendable coroutine.
 */

#include	<coroutine>
#include	<functional>

import log;

export module task;

namespace netd {

template <typename T>
struct promise_base {
	void return_value(T const &value) {
		result = value;
	}

	void return_value(T &&value) {
		result = std::move(value);
	}

	auto await_resume() -> T {
		return std::move(result);
	}

	T result{};
};

template <>
struct promise_base<void> {
	void return_void() {}
	auto await_resume() -> void {}
};

export template <typename T>
struct task {
	struct promise_type : promise_base<T> {
		std::coroutine_handle<> previous{};

		auto get_return_object() {
			return task(std::coroutine_handle<
						promise_type
					>::from_promise(*this));
		}

		auto initial_suspend() noexcept -> std::suspend_always {
			return {};
		}

		struct final_awaiter {
			auto await_ready() noexcept -> bool {
				return false;
			}

			void await_resume() noexcept {}

			auto await_suspend(
				std::coroutine_handle<promise_type> h)
				-> std::coroutine_handle<>
			{
				auto &prev = h.promise().previous;
				if (prev)
					return prev;

				return std::noop_coroutine();
			}
		};

		auto final_suspend() noexcept -> final_awaiter {
			log::debug("promise: final_suspend");
			return {};
		}

		void unhandled_exception() noexcept {
			abort();
		}
	};

	using handle_type = std::coroutine_handle<promise_type>;

	handle_type _handle;

	explicit task(handle_type handle)
	: _handle(handle) {
		log::debug("task@{}: created", static_cast<void *>(this));
	}

	task(task const &) = delete;
	auto operator=(task const &) -> task & = delete;
	auto operator=(task &&other) -> task & = delete;

	task(task &&other)
	: _handle(std::exchange(other._handle, {}))
	{
		log::debug("task@{}: moved", static_cast<void *>(this));
	}

	virtual ~task() {
		if (_handle) {
			log::debug("task@{}: destroyed with handle",
				   static_cast<void *>(this));
			_handle.destroy();
		} else {
			log::debug("task@{}: destroyed without handle",
				   static_cast<void *>(this));
		}
	}

	auto await_ready() -> bool {
		return false;
	}

	template <typename P>
	auto await_suspend(std::coroutine_handle<P> h) {
		log::debug("task@{}: await_suspend", static_cast<void *>(this));
		auto &promise = _handle.promise();
		promise.previous = h;
		return _handle;
	}

	auto await_resume() -> T {
		log::debug("task@{}: await_resume", static_cast<void *>(this));
		return _handle.promise().await_resume();
	}
};

/*
 * a jtask is a joinable task; once it's finished, it'll call the given
 * handler, which should delete the task.
 */
export template<typename T>
struct jtask {
	struct promise_type : promise_base<T> {
		std::coroutine_handle<> previous{};

		auto get_return_object() {
			return jtask(std::coroutine_handle<
						promise_type
					>::from_promise(*this));
		}

		auto initial_suspend() noexcept -> std::suspend_always {
			return {};
		}

		struct final_awaiter {
			auto await_ready() noexcept -> bool {
				return false;
			}

			void await_resume() noexcept {}

			auto await_suspend(
				std::coroutine_handle<promise_type> h)
				-> std::coroutine_handle<>
			{
				auto &prev = h.promise().previous;
				if (prev)
					return prev;

				return std::noop_coroutine();
			}
		};

		auto final_suspend() noexcept -> final_awaiter {
			log::debug("promise: final_suspend");
			if (on_final_suspend)
				on_final_suspend();
			return {};
		}

		void unhandled_exception() noexcept {
			abort();
		}

		std::function<void (void)> on_final_suspend;
	};

	using handle_type = std::coroutine_handle<promise_type>;

	handle_type _handle;

	explicit jtask(handle_type handle)
	: _handle(handle) {
		log::debug("jtask@{}: created", static_cast<void *>(this));
	}

	jtask(jtask const &) = delete;
	auto operator=(jtask const &) -> jtask & = delete;
	auto operator=(jtask &&other) -> jtask & = delete;

	jtask(jtask &&other)
	: _handle(std::exchange(other._handle, {}))
	{
		log::debug("jtask@{}: moved", static_cast<void *>(this));
	}

	virtual ~jtask() {
		if (_handle) {
			log::debug("jtask@{}: destroyed with handle",
				   static_cast<void *>(this));
			_handle.destroy();
		} else {
			log::debug("jtask@{}: destroyed without handle",
				   static_cast<void *>(this));
		}
	}

	auto on_final_suspend(std::function<void (void)> handler) {
		_handle.promise().on_final_suspend = std::move(handler);
	}

	auto await_ready() -> bool {
		return false;
	}

	template <typename P>
	auto await_suspend(std::coroutine_handle<P> h) {
		log::debug("jtask@{}: await_suspend", static_cast<void *>(this));
		auto &promise = _handle.promise();
		promise.previous = h;
		return _handle;
	}

	auto await_resume() -> T {
		log::debug("jtask@{}: await_resume", static_cast<void *>(this));
		return _handle.promise().await_resume();
	}
};

} // namespace netd
